#include <Wire.h>
#include <LiquidCrystal_I2C.h>

LiquidCrystal_I2C lcd(0x27, 20, 4);  // I2C LCD: 20x4

const int movepin   = 2;
const int choosePin = 3;

// ----- MENU OPTIONS -----

const char* mainOptions[] = {
  "Fiction",
  "Nonfiction"
};

const char* fictionCategories[] = {
  "Fantasy",
  "Sci-Fi",
  "Mystery",
  "Romance",
  "Horror"
};

const char* nonFictionCategories[] = {
  "History",
  "Science",
  "Biography",
  "Self-help"
};

const char* selectedMain     = nullptr;
const char* selectedCategory = nullptr;

// ---------- Instruction screen ----------
void showInstructions() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Use buttons:");

  lcd.setCursor(0, 1);
  lcd.print("Green: move arrow");

  lcd.setCursor(0, 2);
  lcd.print("Red: choose/next");

  lcd.setCursor(0, 3);
  lcd.print("Both: back a menu");

  // Wait until both buttons are released
  while (digitalRead(movepin) == LOW || digitalRead(choosePin) == LOW) {
    delay(10);
  }

  delay(1000);  // keep screen up briefly

  // Now wait for a *new* press to continue
  while (true) {
    int downState   = digitalRead(movepin);
    int selectState = digitalRead(choosePin);

    if (downState == LOW || selectState == LOW) {
      while (digitalRead(movepin) == LOW || digitalRead(choosePin) == LOW) {
        delay(10);
      }
      return;
    }
    delay(30);
  }
}

// ---------- SCROLLING MENU WITH ARROW ----------
int menuSelectScrollArrow(const char* question, const char* options[], int numOptions, bool allowBack) {
  if (numOptions <= 0) return -1;

  const int maxVisible = 3;
  int visibleCount = numOptions < maxVisible ? numOptions : maxVisible;

  int selectionIndex     = 0;
  int windowStart        = 0;
  int lastWindowStart    = -1;
  int lastSelectionIndex = -1;

  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print(question);

  while (true) {

    // Redraw only if necessary
    if (windowStart != lastWindowStart || selectionIndex != lastSelectionIndex) {
      for (int line = 0; line < visibleCount; line++) {
        int optIdx = (windowStart + line) % numOptions;
        int row    = 1 + line;

        lcd.setCursor(0, row);
        lcd.print(optIdx == selectionIndex ? ">" : " ");

        lcd.setCursor(1, row);
        lcd.print(options[optIdx]);

        int len = strlen(options[optIdx]);
        for (int c = 1 + len; c < 20; c++) {
          lcd.print(" ");
        }
      }

      for (int line = visibleCount; line < maxVisible; line++) {
        int row = 1 + line;
        lcd.setCursor(0, row);
        lcd.print("                    ");
      }

      lastWindowStart    = windowStart;
      lastSelectionIndex = selectionIndex;
    }

    int downState   = digitalRead(movepin);
    int selectState = digitalRead(choosePin);

    // Back (both buttons)
    if (allowBack && downState == LOW && selectState == LOW) {
      while (digitalRead(movepin) == LOW || digitalRead(choosePin) == LOW) {
        delay(10);
      }
      return -1;
    }

    // Move arrow
    if (downState == LOW) {
      selectionIndex = (selectionIndex + 1) % numOptions;

      if (numOptions > visibleCount) {
        int bottomNext = (windowStart + visibleCount) % numOptions;
        if (selectionIndex == bottomNext) {
          windowStart = (windowStart + 1) % numOptions;
        }
      }

      while (digitalRead(movepin) == LOW) {
        delay(10);
      }
    }
    // Select
    else if (selectState == LOW) {
      while (digitalRead(choosePin) == LOW) {
        delay(10);
      }
      return selectionIndex;
    }

    delay(30);
  }
}


// ---------- BOOK STRUCTURE ----------
struct Book {
  const char* title;
  const char* type;
  const char* category;
};

const Book books[] = {
  { "The Hobbit",       "Fiction",   "Fantasy" },
  { "Harry Potter 1",   "Fiction",   "Fantasy" },
  { "Dune",             "Fiction",   "Sci-Fi" },
  { "Ender's Game",     "Fiction",   "Sci-Fi" },
  { "Sherlock Holmes",  "Fiction",   "Mystery" },
  { "Sapiens",          "Nonfiction","History" },
  { "Brief History...", "Nonfiction","Science" },
  { "Steve Jobs",       "Nonfiction","Biography" },
  { "Atomic Habits",    "Nonfiction","Self-help" }
};

const int NUM_BOOKS = sizeof(books) / sizeof(books[0]);

int buildBookList(const char* type, const char* category,
                  const char* outTitles[], int maxOut) {
  int count = 0;
  for (int i = 0; i < NUM_BOOKS && count < maxOut; i++) {
    if (strcmp(books[i].type, type) == 0 &&
        strcmp(books[i].category, category) == 0) {
      outTitles[count++] = books[i].title;
    }
  }
  return count;
}


// ---------- SETUP ----------
void setup() {
  delay(300);  // Give LCD time to wake up
  lcd.init();
  lcd.backlight();
  lcd.clear();

  pinMode(movepin,   INPUT_PULLUP);
  pinMode(choosePin, INPUT_PULLUP);

  Serial.begin(9600);
}


// ---------- MAIN LOOP ----------
void loop() {
  showInstructions();

  // Menu 1: Fiction / Nonfiction
  int mainIndex = menuSelectScrollArrow("What do you like?", mainOptions, 2, false);
  selectedMain  = mainOptions[mainIndex];

  // Menu 2: Category (with back allowed)
  while (true) {
    const char* question = "Pick 1 category:";
    const char** categoryOptions;
    int          numCategories;

    if (mainIndex == 0) {
      categoryOptions = fictionCategories;
      numCategories   = sizeof(fictionCategories) / sizeof(fictionCategories[0]);
    } else {
      categoryOptions = nonFictionCategories;
      numCategories   = sizeof(nonFictionCategories) / sizeof(nonFictionCategories[0]);
    }

    int catIndex = menuSelectScrollArrow(question, categoryOptions, numCategories, true);

    if (catIndex == -1) {
      mainIndex   = menuSelectScrollArrow("What do you like?", mainOptions, 2, false);
      selectedMain = mainOptions[mainIndex];
      continue;
    }

    selectedCategory = categoryOptions[catIndex];
    break;
  }

  lcd.clear();
  lcd.setCursor(0, 0); lcd.print("You chose:");
  lcd.setCursor(0, 1); lcd.print(selectedMain);
  lcd.setCursor(0, 2); lcd.print(selectedCategory);
  delay(2000);
  lcd.clear();

  // Books
  const char* matches[10];
  int m = buildBookList(selectedMain, selectedCategory, matches, 10);

  if (m > 0) {
    int idx = menuSelectScrollArrow("Pick a book:", matches, m, false);
    const char* chosen = matches[idx];

    lcd.clear();
    lcd.setCursor(0, 0); lcd.print("You chose:");
    lcd.setCursor(0, 1); lcd.print(selectedMain);
    lcd.setCursor(0, 2); lcd.print(selectedCategory);
    lcd.setCursor(0, 3); lcd.print(chosen);
    delay(4000);
  } else {
    lcd.clear();
    lcd.setCursor(0, 0); lcd.print("No books found");
    lcd.setCursor(0, 1); lcd.print(selectedMain);
    lcd.setCursor(0, 2); lcd.print(selectedCategory);
    delay(2000);
  }
}
